name: Publish DMG Release

on:
  workflow_dispatch:
    inputs:
      asana-task-url:
        description: "Asana release task URL"
        required: true
        type: string
      tag:
        description: "Tag to publish"
        required: true
        type: string
      release-type:
        description: "Release type"
        required: true
        type: choice
        options:
        - internal
        - public
        - hotfix

jobs:

  # This is only run for public and hotfix releases
  # Internal release has been tagged as part of code_freeze or bump_interal_release workflows
  # tag-public-release:

  #   name: Tag public release

  #   if: ${{ github.event.inputs.release-type != 'internal' }}

  #   uses: ./.github/workflows/tag_release.yml
  #   with:
  #     asana-task-url: ${{ github.event.inputs.asana-task-url }}
  #     branch: ${{ github.ref_name }}
  #     prerelease: false
  #   secrets:
  #     ASANA_ACCESS_TOKEN: ${{ secrets.ASANA_ACCESS_TOKEN }}
  #     GHA_ELEVATED_PERMISSIONS_TOKEN: ${{ secrets.GHA_ELEVATED_PERMISSIONS_TOKEN }}

  publish-to-sparkle:

    name: Publish a release to Sparkle

    # needs: [tag-public-release]

    # Allow to run even if the tag-public-release job was skipped (e.g. for internal releases)
    # or failed (for public releases or hotfixes), because tagging doesn't block publishing the release
    if: always()

    runs-on: macos-13-xlarge
    timeout-minutes: 10

    env:
      SPARKLE_DIR: ${{ github.workspace }}/sparkle-updates

    steps:

      - name: Verify the tag
        id: verify-tag
        env:
          tag: ${{ github.event.inputs.tag }}
        run: |
          tag_regex='^[0-9]+\.[0-9]+\.[0-9]+-[0-9]+$'

          if [[ ! "$tag" =~ $tag_regex ]]; then
            echo "::error::The provided tag ($tag) has incorrect format (attempted to match ${tag_regex})."
            exit 1
          fi
          echo "release-version=${tag//-/.}" >> $GITHUB_OUTPUT

      # - name: Check out the code
      #   uses: actions/checkout@v4
      #   with:
      #     submodules: recursive

      # - name: Select Xcode
      #   run: sudo xcode-select -s /Applications/Xcode_$(<.xcode-version).app/Contents/Developer

      # - name: Set up Sparkle tools
      #   env:
      #     SPARKLE_URL: https://github.com/sparkle-project/Sparkle/releases/download/${{ vars.SPARKLE_VERSION }}/Sparkle-${{ vars.SPARKLE_VERSION }}.tar.xz
      #   run: |
      #     curl -fLSs $SPARKLE_URL | tar xJ bin
      #     echo "${{ github.workspace }}/bin" >> $GITHUB_PATH

      # - name: Fetch DMG
      #   id: fetch-dmg
      #   if: ${{ github.event.inputs.release-type != 'public' }}
      #   env:
      #     DMG_NAME: duckduckgo-${{ steps.verify-tag.outputs.release-version }}.dmg
      #   run: |
      #     # Public release doesn't need fetching a DMG (it's already uploaded to S3)
      #     if [[ "${{ github.event.inputs.release-type }}" != 'public' ]]; then
      #       DMG_URL="${{ vars.DMG_URL_ROOT }}${DMG_NAME}"
      #       curl -fLSs -o "$DMG_NAME" "$DMG_URL"
      #     fi
      #     echo "dmg-name=$DMG_NAME" >> $GITHUB_OUTPUT
      #     echo "dmg-path=$DMG_NAME" >> $GITHUB_OUTPUT

      # - name: Extract Asana Task ID
      #   id: task-id
      #   uses: ./.github/actions/asana-extract-task-id
      #   with:
      #     task-url: ${{ github.event.inputs.asana-task-url }}

      # - name: Fetch release notes
      #   env:
      #     TASK_ID: ${{ steps.task-id.outputs.task-id }}
      #     ASANA_ACCESS_TOKEN: ${{ secrets.ASANA_ACCESS_TOKEN }}
      #   run: |
      #     curl -fLSs "https://app.asana.com/api/1.0/tasks/${TASK_ID}?opt_fields=notes" \
      #       -H "Authorization: Bearer ${ASANA_ACCESS_TOKEN}" \
      #       | jq -r .data.notes \
      #       | ./scripts/extract_release_notes.sh > release_notes.txt
      #     echo "RELEASE_NOTES_FILE=release_notes.txt" >> $GITHUB_ENV

      # - name: Generate appcast
      #   id: appcast
      #   env:
      #     DMG_PATH: ${{ steps.fetch-dmg.outputs.dmg-path }}
      #     SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
      #     RELEASE_TYPE: ${{ github.event.inputs.release-type }}
      #     VERSION: ${{ steps.verify-tag.outputs.release-version }}
      #   run: |
      #     echo -n "$SPARKLE_PRIVATE_KEY" > sparkle_private_key
      #     chmod 600 sparkle_private_key

      #     case "$RELEASE_TYPE" in
      #       "internal")
      #         ./scripts/appcast_manager/appcastManager.swift \
      #           --release-to-internal-channel \
      #           --dmg ${DMG_PATH} \
      #           --release-notes release_notes.txt \
      #           --key sparkle_private_key
      #         ;;
      #       "public")
      #         ./scripts/appcast_manager/appcastManager.swift \
      #           --release-to-public-channel \
      #           --version ${VERSION} \
      #           --release-notes release_notes.txt \
      #           --key sparkle_private_key
      #         ;;
      #       "hotfix")
      #         ./scripts/appcast_manager/appcastManager.swift \
      #           --release-hotfix-to-public-channel \
      #           --dmg ${DMG_PATH} \
      #           --release-notes release_notes.txt \
      #           --key sparkle_private_key
      #         ;;
      #       *)
      #         ;;
      #     esac

      #     appcast_patch_name="appcast2-${VERSION}.patch"
      #     mv -f ${{ env.SPARKLE_DIR }}/appcast_diff.txt ${{ env.SPARKLE_DIR }}/${appcast_patch_name}
      #     echo "appcast-patch-name=${appcast_patch_name}" >> $GITHUB_OUTPUT
          
      # - name: Upload appcast diff artifact
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: ${{ steps.appcast.outputs.appcast-patch-name }}
      #     path: ${{ env.SPARKLE_DIR }}/${{ steps.appcast.outputs.appcast-patch-name }}

      # - name: Upload to S3
      #   id: upload
      #   env:
      #     AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_RELEASE_S3 }}
      #     AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_RELEASE_S3 }}
      #     AWS_DEFAULT_REGION: ${{ vars.AWS_DEFAULT_REGION }}
      #     RELEASE_TYPE: ${{ github.event.inputs.release-type }}
      #     VERSION: ${{ steps.verify-tag.outputs.release-version }}
      #   run: |
      #     # Back up existing appcast2.xml
      #     OLD_APPCAST_NAME=appcast2_old.xml
      #     echo "OLD_APPCAST_NAME=${OLD_APPCAST_NAME}" >> $GITHUB_ENV
      #     curl -fLSs "${{ vars.DMG_URL_ROOT }}appcast2.xml" --output "${OLD_APPCAST_NAME}"

      #     # Upload files to S3
      #     if [[ "${RELEASE_TYPE}" == "internal" ]]; then
      #       ./scripts/upload_to_s3/upload_to_s3.sh --run --force
      #     else
      #       ./scripts/upload_to_s3/upload_to_s3.sh --run --force --overwrite-duckduckgo-dmg "${VERSION}"
      #     fi

      #     if [[ -f "${{ env.SPARKLE_DIR }}/uploaded_files_list.txt" ]]; then
      #       echo "FILES_UPLOADED=$(awk '{ print "<li><code>"$1"</code></li>"; }' < ${{ env.SPARKLE_DIR }}/uploaded_files_list.txt | tr '\n' ' ')" >> $GITHUB_ENV
      #     else
      #       echo "FILES_UPLOADED='No files uploaded.'" >> $GITHUB_ENV
      #     fi

      # - name: Update Asana for the release
      #   id: update-asana
      #   if: ${{ github.event.inputs.release-type != 'internal' }}
      #   continue-on-error: true
      #   env:
      #     ASANA_ACCESS_TOKEN: ${{ secrets.ASANA_ACCESS_TOKEN }}
      #     BRANCH: ${{ github.ref_name }}
      #   run: |
      #     version="$(cut -d '/' -f 2 <<< "$BRANCH")"
      #     ./scripts/update_asana_for_release.sh public \
      #       ${{ steps.task-id.outputs.task-id }} \
      #       ${{ vars.MACOS_APP_BOARD_DONE_SECTION_ID }} \
      #       "${version}" \
      #       announcement-task-contents.txt
      #     echo "announcement-task-contents=$(sed 's/"/\\"/g' < announcement-task-contents.txt)" >> $GITHUB_OUTPUT

      # - name: Set common environment variables
      #   if: always()
      #   env:
      #     DMG_NAME: ${{ steps.fetch-dmg.outputs.dmg-name }}
      #   run: |
      #     echo "APPCAST_PATCH_NAME=${{ steps.appcast.outputs.appcast-patch-name }}" >> $GITHUB_ENV
      #     echo "DMG_NAME=${DMG_NAME}" >> $GITHUB_ENV
      #     echo "DMG_URL=${{ vars.DMG_URL_ROOT }}${DMG_NAME}" >> $GITHUB_ENV
      #     echo "RELEASE_BUCKET_NAME=${{ vars.RELEASE_BUCKET_NAME }}" >> $GITHUB_ENV
      #     echo "RELEASE_BUCKET_PREFIX=${{ vars.RELEASE_BUCKET_PREFIX }}" >> $GITHUB_ENV
      #     echo "RELEASE_TASK_ID=${{ steps.task-id.outputs.task-id }}" >> $GITHUB_ENV
      #     echo "TAG=${{ github.event.inputs.tag }}" >> $GITHUB_ENV
      #     echo "VERSION=${{ steps.verify-tag.outputs.release-version }}" >> $GITHUB_ENV
      #     echo "WORKFLOW_URL=https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_ENV

      # - name: Set up Asana templates
      #   if: always()
      #   id: asana-templates
      #   env:
      #     RELEASE_TYPE: ${{ github.event.inputs.release-type }}
      #   run: |
      #     if [[ ${{ steps.upload.outcome }} == "success" ]]; then  
      #       if [[ "${RELEASE_TYPE}" == "internal" ]]; then
      #         echo "task-template=validate-check-for-updates-internal" >> $GITHUB_OUTPUT
      #         echo "comment-template=validate-check-for-updates-internal" >> $GITHUB_OUTPUT
      #         echo "release-task-comment-template=internal-release-complete" >> $GITHUB_OUTPUT
      #       else
      #         echo "task-template=validate-check-for-updates-public" >> $GITHUB_OUTPUT
      #         echo "comment-template=validate-check-for-updates-public" >> $GITHUB_OUTPUT
      #         echo "release-task-comment-template=public-release-complete" >> $GITHUB_OUTPUT
      #       fi
      #     else
      #       echo "task-template=appcast-failed-${RELEASE_TYPE}" >> $GITHUB_OUTPUT
      #       echo "comment-template=appcast-failed-${RELEASE_TYPE}" >> $GITHUB_OUTPUT
      #     fi

      # - name: Create Asana task
      #   id: create-task
      #   if: always()
      #   uses: ./.github/actions/asana-create-action-item
      #   with:
      #     access-token: ${{ secrets.ASANA_ACCESS_TOKEN }}
      #     release-task-url: ${{ github.event.inputs.asana-task-url }}
      #     template-name: ${{ steps.asana-templates.outputs.task-template }}

      # - name: Create Asana task to handle Asana paperwork
      #   id: create-asana-paperwork-task
      #   if: ${{ steps.update-asana.outcome == 'failure' }}
      #   uses: ./.github/actions/asana-create-action-item
      #   env:
      #     APP_BOARD_ASANA_PROJECT_ID: ${{ vars.MACOS_APP_BOARD_ASANA_PROJECT_ID }}
      #   with:
      #     access-token: ${{ secrets.ASANA_ACCESS_TOKEN }}
      #     release-task-url: ${{ github.event.inputs.asana-task-url }}
      #     template-name: update-asana-for-public-release

      # - name: Create Asana task to announce the release
      #   id: create-announcement-task
      #   if: ${{ github.event.inputs.release-type != 'internal' }}
      #   uses: ./.github/actions/asana-create-action-item
      #   env:
      #     html-notes: ${{ steps.update-asana.outputs.announcement-task-contents }}
      #   with:
      #     access-token: ${{ secrets.ASANA_ACCESS_TOKEN }}
      #     html-notes: ${{ env.html-notes }}
      #     release-task-url: ${{ github.event.inputs.asana-task-url }}
      #     task-name: Announce the release to the company

      # - name: Upload patch to the Asana task
      #   id: upload-patch
      #   if: success()
      #   uses: ./.github/actions/asana-upload
      #   with:
      #     access-token: ${{ secrets.ASANA_ACCESS_TOKEN }}
      #     file-name: ${{ env.SPARKLE_DIR }}/${{ steps.appcast.outputs.appcast-patch-name }}
      #     task-id: ${{ steps.create-task.outputs.new-task-id }}

      # - name: Upload old appcast file to the Asana task
      #   id: upload-old-appcast
      #   if: success()
      #   uses: ./.github/actions/asana-upload
      #   with:
      #     access-token: ${{ secrets.ASANA_ACCESS_TOKEN }}
      #     file-name: ${{ env.OLD_APPCAST_NAME }}
      #     task-id: ${{ steps.create-task.outputs.new-task-id }}
  
      # - name: Upload release notes to the Asana task
      #   id: upload-release-notes
      #   if: success()
      #   uses: ./.github/actions/asana-upload
      #   with:
      #     access-token: ${{ secrets.ASANA_ACCESS_TOKEN }}
      #     file-name: ${{ env.RELEASE_NOTES_FILE }}
      #     task-id: ${{ steps.create-task.outputs.new-task-id }}
        
      # - name: Report status
      #   if: always()
      #   uses: ./.github/actions/asana-log-message
      #   env:
      #     ANNOUNCEMENT_TASK_ID: ${{ steps.create-announcement-task.outputs.new-task-id }}
      #     ASSIGNEE_ID: ${{ steps.create-task.outputs.assignee-id }}
      #     TASK_ID: ${{ steps.create-task.outputs.new-task-id }}
      #   with:
      #     access-token: ${{ secrets.ASANA_ACCESS_TOKEN }}
      #     task-url: ${{ github.event.inputs.asana-task-url }}
      #     template-name: ${{ steps.asana-templates.outputs.comment-template }}

      # - name: Add a comment to the release task
      #   if: success()
      #   uses: ./.github/actions/asana-add-comment
      #   with:
      #     access-token: ${{ secrets.ASANA_ACCESS_TOKEN }}
      #     task-url: ${{ github.event.inputs.asana-task-url }}
      #     template-name: ${{ steps.asana-templates.outputs.release-task-comment-template }}

  # This is only run for public and hotfix releases
  create-variants:

    name: Create DMG Variants

    needs: [publish-to-sparkle]

    if: ${{ github.event.inputs.release-type != 'internal' }}

    uses: duckduckgo/macos-browser/.github/workflows/create_variants.yml@main
    secrets:
      BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
      P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      REVIEW_PROVISION_PROFILE_BASE64: ${{ secrets.REVIEW_PROVISION_PROFILE_BASE64 }}
      RELEASE_PROVISION_PROFILE_BASE64: ${{ secrets.RELEASE_PROVISION_PROFILE_BASE64 }}
      DBP_AGENT_RELEASE_PROVISION_PROFILE_BASE64: ${{ secrets.DBP_AGENT_RELEASE_PROVISION_PROFILE_BASE64 }}
      DBP_AGENT_REVIEW_PROVISION_PROFILE_BASE64: ${{ secrets.DBP_AGENT_REVIEW_PROVISION_PROFILE_BASE64 }}
      NETP_SYSEX_RELEASE_PROVISION_PROFILE_BASE64_V2: ${{ secrets.NETP_SYSEX_RELEASE_PROVISION_PROFILE_BASE64_V2 }}
      NETP_SYSEX_REVIEW_PROVISION_PROFILE_BASE64_V2: ${{ secrets.NETP_SYSEX_REVIEW_PROVISION_PROFILE_BASE64_V2 }}
      NETP_AGENT_RELEASE_PROVISION_PROFILE_BASE64_V2: ${{ secrets.NETP_AGENT_RELEASE_PROVISION_PROFILE_BASE64_V2 }}
      NETP_AGENT_REVIEW_PROVISION_PROFILE_BASE64_V2: ${{ secrets.NETP_AGENT_REVIEW_PROVISION_PROFILE_BASE64_V2 }}
      NETP_NOTIFICATIONS_RELEASE_PROVISION_PROFILE_BASE64: ${{ secrets.NETP_NOTIFICATIONS_RELEASE_PROVISION_PROFILE_BASE64 }}
      NETP_NOTIFICATIONS_REVIEW_PROVISION_PROFILE_BASE64: ${{ secrets.NETP_NOTIFICATIONS_REVIEW_PROVISION_PROFILE_BASE64 }}
      APPLE_API_KEY_BASE64: ${{ secrets.APPLE_API_KEY_BASE64 }}
      APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
      APPLE_API_KEY_ISSUER: ${{ secrets.APPLE_API_KEY_ISSUER }}
      ASANA_ACCESS_TOKEN: ${{ secrets.ASANA_ACCESS_TOKEN }}
      MM_HANDLES_BASE64: ${{ secrets.MM_HANDLES_BASE64 }}
      MM_WEBHOOK_URL: ${{ secrets.MM_WEBHOOK_URL }}
      AWS_ACCESS_KEY_ID_RELEASE_S3: ${{ secrets.AWS_ACCESS_KEY_ID_RELEASE_S3 }}
      AWS_SECRET_ACCESS_KEY_RELEASE_S3: ${{ secrets.AWS_SECRET_ACCESS_KEY_RELEASE_S3 }}
