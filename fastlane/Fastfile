# frozen_string_literal: true

UI.abort_with_message!('Please run fastlane via `bundle exec`') unless FastlaneCore::Helper.bundler?

########################################################################
# Environment Variables
########################################################################
DEFAULT_BRANCH = 'develop'
RELEASE_BRANCH = 'release'
PROJECT_ROOT_FOLDER = File.dirname(File.expand_path(__dir__))
VERSION_CONFIG_PATH = File.join(PROJECT_ROOT_FOLDER, 'Configuration/Version.xcconfig')
VERSION_CONFIG_DEFINITION = 'MARKETING_VERSION'
UPGRADABLE_EMBEDDED_FILES = [
  'DuckDuckGo/Content Blocker/AppTrackerDataSetProvider.swift',
  'DuckDuckGo/Content Blocker/trackerData.json',
  'DuckDuckGo/Content Blocker/AppPrivacyConfigurationDataProvider.swift',
  'DuckDuckGo/Content Blocker/macos-config.json'
].freeze

default_platform(:mac)

platform :mac do
  #################################################
  # Public lanes
  #################################################
  lane :sync_signing do
    sync_code_signing(
      type: "appstore",
      api_key: get_api_key
    )
  end

  lane :sync_signing_dev do |options|
    sync_code_signing(
      type: "development",
      additional_cert_types: [],
      app_identifier: "com.duckduckgo.mobile.ios.*",
      api_key: get_api_key,
      generate_apple_certs: true,
      keychain_name: options[:keychain_name],
      keychain_password: options[:keychain_password]
    )
  end

  lane :release_testflight do
    sync_signing

    build_app(
      export_method: "app-store",
      scheme: "DuckDuckGo Privacy Browser App Store",
      export_options: "scripts/assets/AppStoreExportOptions.plist"
    )

    upload_to_testflight(
      api_key: get_api_key
    )

    # deliver(
    #   submit_for_review: false,
    #   automatic_release: false,
    #   phased_release: true,
    #   force: true,
    #   skip_screenshots: true,
    #   precheck_include_in_app_purchases: false,
    #   submission_information: {
    #      add_id_info_uses_idfa: false
    #   }
    # )

  end

  # Executes the release preparation work in the repository
  #
  # - Cuts a new release branch
  # - Updates submodules and embedded files
  #
  # @option [String] version (default: nil) Marketing version string
  # @option [Boolean] skip_confirm (default: false) If true, avoids any interactive prompt
  #
  desc 'Executes the release preparation work in the repository'
  lane :code_freeze do |options|
    macos_codefreeze_prechecks
    new_version = validate_new_version(options)
    macos_create_release_branch(version: new_version)
    macos_update_embedded_files
    macos_update_version_config(version: new_version)
  end

  #################################################
  # Helper functions
  #################################################
  private_lane :get_api_key do
    has_api_key = [
      "APPLE_API_KEY_ID",
      "APPLE_API_KEY_ISSUER",
      "APPLE_API_KEY_BASE64"
    ].map {|x| ENV.has_key? x}.reduce(&:&)

    if has_api_key
      app_store_connect_api_key(
        key_id: ENV["APPLE_API_KEY_ID"],
        issuer_id: ENV["APPLE_API_KEY_ISSUER"],
        key_content: ENV["APPLE_API_KEY_BASE64"],
        is_key_content_base64: true
      )
    else
      nil
    end
  end

  # Ensures that the local repository is in good shape for the release:
  #
  # - Checks out the default branch
  # - Ensures git status is clean
  #
  private_lane :macos_codefreeze_prechecks do
    ensure_git_status_clean

    ensure_git_branch(branch: DEFAULT_BRANCH)
    git_pull

    git_submodule_update(recursive: true, init: true)
    ensure_git_status_clean
  end

  # Calculates the new version or validate the provided one, if it exists
  # and prompts the user to confirm
  #
  # @option [String] version (default: nil) Marketing version string
  #
  private_lane :validate_new_version do |options|
    current_version = macos_current_version
    user_version = format_user_version(options[:version])
    new_version = user_version.nil? ? macos_bump_patch_version(current_version) : user_version
    unless UI.confirm(
      "Current version is #{current_version}.\nNew version is #{new_version}.\nDo you want to continue?"
    )
      UI.abort_with_message!('Aborted by user.')
    end
    new_version
  end

  # Checks out a new branch from the current commit and pushes it
  #
  # @option [String] version (default: nil) Marketing version string
  #
  private_lane :macos_create_release_branch do |options|
    version = options[:version]
    UI.message("Creating new release branch for #{version}")
    release_branch = "#{RELEASE_BRANCH}/#{version}"

    # Abort if the branch already exists
    UI.abort_with_message!("Branch #{release_branch} already exists in this repository. Aborting.") unless Action.sh(
      'git', 'branch', '--list', release_branch
    ).empty?

    # Create the branch and push
    Action.sh('git', 'checkout', '-b', release_branch)
    Action.sh('git', 'push', '-u', 'origin', release_branch)
  end

  # Updates embedded files:
  #
  # - Calls update_embedded.sh shell script
  # - Validate the changed files against the known ones list
  # - Runs automated tests
  # - Commits and pushes
  #
  private_lane :macos_update_embedded_files do
    sh("cd #{PROJECT_ROOT_FOLDER} && ./scripts/update_embedded.sh")

    # Verify no unexpected files were modified
    result = sh('git', 'status')
    modified_files = result.split("\n").select { |line| line.include?('modified:') }
    modified_files = modified_files.map { |str| str.split(':')[1].strip }
    nopref_modified_files = modified_files.map { |str| str.delete_prefix('../') }
    nopref_modified_files.each do |modified_file|
      UI.abort_with_message!("Unexpected change to #{modified_file}.") unless UPGRADABLE_EMBEDDED_FILES.any? do |s|
        s.include?(modified_file)
      end
    end

    # Run tests
    run_tests(scheme: 'DuckDuckGo Privacy Browser')

    # Every thing looks good: commit and push
    modified_files.each { |modified_file| sh('git', 'add', modified_file.to_s) }
    sh('git', 'commit', '-m', 'Update embedded files')
    ensure_git_status_clean
    sh('git', 'push')
  end

  # Updates version in the config file
  #
  # @option [String] version (default: nil) Marketing version string
  #
  private_lane :macos_update_version_config do |options|
    version = options[:version]
    File.write(VERSION_CONFIG_PATH, "#{VERSION_CONFIG_DEFINITION} = #{version}\n")
    git_commit(path: VERSION_CONFIG_PATH, message: "Version Bump to #{version}")
    sh('git', 'push')
  end

  # Updates version in the config file
  #
  # @return [String] version read from the file, or nil in case of failure
  #
  def macos_current_version
    current_version = nil

    file_data = File.read(VERSION_CONFIG_PATH).split("\n")
    file_data.each do |line|
      current_version = line.split('=')[1].strip if line.start_with?(VERSION_CONFIG_DEFINITION)
    end

    current_version
  end

  # Updates version in the config file by bumping the patch (third) number
  #
  # @param [String] current version
  # @return [String] updated version
  #
  def macos_bump_patch_version(current_version)
    current_version_array = current_version.split('.')
    new_patch_number = current_version_array[2].to_i + 1
    "#{current_version_array[0]}.#{current_version_array[1]}.#{new_patch_number}"
  end

  # Formats the version provided by the user to be Major.Minor.Patch
  #
  # @param [String] original version string
  # @return [String] formatted version string
  #
  def format_user_version(version)
    user_version = nil

    unless version.nil?
      version_numbers = version.split('.')
      version_numbers[3] = 0
      version_numbers.map! { |element| element.nil? ? 0 : element }
      user_version = "#{version_numbers[0]}.#{version_numbers[1]}.#{version_numbers[2]}"
    end

    user_version
  end
end
